\# This write-up documents my progress through the first introductory picoCTF challenges, focusing specifically on First Grep and First Find. These challenges are designed to introduce basic Linux command-line skills that are essential for solving Capture The Flag (CTF) problems. Through completing these tasks, I developed foundational knowledge in file handling, searching, and navigation within a Linux environment.

Getting Started with picoCTF

Understanding the Platform

picoCTF is a beginner-friendly Capture The Flag (CTF) platform designed to teach cybersecurity concepts through hands-on challenges. Each challenge presents a small problem and rewards a flag, usually in the format:

picoCTF{\...}

Before touching advanced topics, picoCTF ensures learners are comfortable with:

The Linux terminal

Basic command-line tools

Reading challenge descriptions carefully

This foundation is critical because later challenges assume terminal fluency

Challenge 1: First Grep

Objective:

The goal of the First Grep challenge was to locate the flag hidden inside a text file using the grep command.

![](media/image6.png){width="6.5in" height="4.013888888888889in"}

### **Approach**

I attempted to download the challenge file using wget to retrieve the provided artifact from the picoCTF server for analysis. Although the connection to the server was successful, the download failed due to a "No space left on device" error, indicating that the picoCTF webshell environment had reached its storage limit. After this, I used the file command to identify the nature of the downloaded content, which revealed that the file was ASCII text with very long lines, suggesting that the data was text-based but likely encoded or obfuscated. I then used cat to display the contents of the file, which resulted in unreadable, seemingly random characters, confirming that the file was not meant to be interpreted directly in its raw form. These steps helped establish that the challenge involved further decoding or analysis rather than simple plaintext inspection.

I was provided with a text file containing a large amount of data. Instead of manually scanning the file, I used the grep command to search for a specific keyword associated with the flag format (picoCTF{}).

Command Used:

grep 'picoCTF' file.txt

Outcome:

The command successfully displayed the line containing the flag. This challenge helped me understand how powerful grep is for efficiently searching through files, especially when dealing with large datasets.

![](media/image10.png){width="6.5in" height="1.6527777777777777in"}

Key Takeaways:

Learned how to use grep to search for patterns in files

Understood the importance of command-line tools in speeding up problem solving

Recognized that flags often follow predictable formats that can be searched programmatical

Right after those first basic challenges i tried the next challenge available here

![](media/image4.png){width="6.5in" height="3.263888888888889in"}

Following the important commands to use to get the flags.

![](media/image8.png){width="6.5in" height="3.0555555555555554in"}

For this challenge, I attempted to download the provided ZIP archive using wget in the picoCTF webshell in order to analyze its contents. Although the connection to the picoCTF artifact server was successful, the download failed due to a "No space left on device" error, indicating that the webshell environment had reached its storage limit. Despite this limitation, the extracted directory structure was already present in the environment, allowing further exploration without re-downloading the file. To better understand the task, I consulted the manual page for the find command using man find, as the challenge hinted at locating a specific file within a large directory hierarchy.

After familiarizing myself with the find utility, I used it to recursively search through the directory structure for the target file named uber-secret.txt. The command output revealed the full path of the file, which was deeply nested within multiple subdirectories. This confirmed that manually navigating the directories would have been inefficient, and that find was the appropriate tool for locating files in complex directory hierarchies. Once the file path was identified, I was able to access the file and retrieve the flag.

![](media/image5.png){width="6.5in" height="4.680555555555555in"}

![](media/image3.png){width="6.5in" height="5.263888888888889in"}

![](media/image9.png){width="6.5in" height="3.0694444444444446in"}

![](media/image2.png){width="5.671875546806649in" height="2.5723403324584426in"}![](media/image7.png){width="6.345238407699037in" height="4.484375546806649in"}

\# PicoCTF Challenge \#301 - Disk Analysis Writeup

\## Challenge Information

\- \*\*Challenge Name:\*\* Disk analysis

\- \*\*Category:\*\* Forensics - Disk Analysis

\- \*\*Difficulty:\*\* Intermediate

\- \*\*Challenge URL:\*\* https://play.picoctf.org/practice/challenge/301

\## Challenge Description

This challenge introduces fundamental disk forensics skills by working with disk images. The task involves using Sleuthkit command-line tools to analyze a disk image, identify partitions, and extract the flag. The challenge also introduces using \`netcat (nc)\` to verify the answer with a remote checker program.

\-\--

\## What I Did

\### Step 1: Downloaded the Challenge File

First, I downloaded the disk image file from the challenge artifacts:

\`\`\`bash

\$ wget https://artifacts.picoctf.net/c/331/disk.flag.img.gz

\`\`\`

\### Step 2: Decompressed the Disk Image

The file was compressed with gzip, so I decompressed it:

\`\`\`bash

\$ gunzip disk.flag.img.gz

\`\`\`

This extracted \`disk.flag.img\`, which is the disk image ready for analysis.

\### Step 3: Analyzed the Partition Table

Using the Sleuthkit tool \`mmls\`, I dumped the partition table to understand the disk structure:

\`\`\`bash

\$ mmls disk.flag.img

\`\`\`

\*\*Output:\*\*

\`\`\`

DOS Partition Table

Offset Sector: 0

Units are in 512-byte sectors

Slot Start End Length Description

000: Meta 0000000000 0000000000 0000000001 Primary Table (#0)

001: \-\-\-\-\-\-- 0000000000 0000002047 0000002048 Unallocated

002: 000:000 0000002048 0000206847 0000204800 Linux (0x83)

003: 000:001 0000206848 0000360447 0000153600 Linux Swap / Solaris x86 (0x82)

004: 000:002 0000360448 0000614399 0000253952 Linux (0x83)

\`\`\`

\### Step 4: Identified the Target Partition

I analyzed the partition table and identified that \*\*partition 004\*\* (the fourth entry) was the main Linux partition because:

\- It had the largest length (253952 sectors)

\- It was labeled as \`Linux (0x83)\`

\- It had an uneven/significant length suggesting it contained data

The \*\*Start sector\*\* for this partition was: \*\*0000360448\*\*

\### Step 5: Verified the Answer with Netcat

The challenge required submitting the answer to a checker program via netcat:

\`\`\`bash

\$ nc saturn.picoctf.net 52279

\`\`\`

When prompted with: \*\"What is the size of the Linux partition in the given disk image?\"\*

I responded with the length in sectors: \*\*202752\*\*

\*\*Result:\*\* The checker confirmed the answer and returned the flag! ðŸŽ‰

\-\--

\## What Happened

The challenge walked me through a typical disk forensics workflow:

1\. \*\*Acquired the evidence\*\* - Downloaded the disk image

2\. \*\*Prepared the evidence\*\* - Decompressed the file

3\. \*\*Analyzed the structure\*\* - Used \`mmls\` to view the partition layout

4\. \*\*Identified relevant data\*\* - Determined which partition contained the main filesystem

5\. \*\*Extracted the answer\*\* - Found the partition size and verified it remotely

The remote checker validated my understanding by requiring the correct partition size as input.

\-\--

\## Key Learnings

\### Technical Skills

1\. Sleuthkit Tools:

\- \`mmls\` - Displays the partition table of a disk image, showing sector offsets, sizes, and partition types

\- Understanding DOS partition tables and sector-based addressing

2\. \*\*Disk Forensics Fundamentals:\*\*

\- Disk images contain multiple partitions with different purposes (boot, swap, data)

\- Partitions are measured in sectors (typically 512 bytes each)

\- The \"Start\" value indicates where a partition begins on the disk

\- Identifying the main partition requires analyzing size and partition type

3\. \*\*Command-Line Tools:\*\*

\- \`wget\` for downloading files

\- \`gunzip\` for decompressing gzip archives

\- \`netcat (nc)\` for network communication with remote services

\### Forensics Methodology

\- Details matter - Disk analysis requires careful attention to offsets, sizes, and partition types

\- Tool selection - Using individual Sleuthkit tools provides more granular control and learning compared to GUI tools like Autopsy

\- Evidence preservation- Working with disk images (not physical drives) is standard practice in digital forensics

\### Problem-Solving Approach

\- Read partition tables systematically

\- Identify the target based on logical reasoning (size, type, position)

\- Verify findings with the challenge infrastructure before finalizing the answer

\-\--

\## Tools Used

\- \`wget\` - File download utility

\- \`gunzip\` - Decompression tool

\- \`mmls\` (Sleuthkit) - Partition table analyzer

\- \`netcat (nc)\` - Network utility for remote communication

\## Flag

Successfully retrieved the flag by submitting the correct partition size (202752 sectors) to the remote checker.

![](media/image1.png){width="6.5in" height="2.3472222222222223in"}

\## Conclusion

This challenge provided an excellent introduction to disk forensics fundamentals. It reinforced the importance of understanding disk structures, partition tables, and using specialized forensics tools like Sleuthkit. The hands-on experience with \`mmls\` and interpreting partition data is directly applicable to real-world digital forensics investigations. I also find it very challenging in recalling the commands and it was a very satisfying feeling after learning from it within an hour walkthrough and discovering each commands and having difficulties for a beginner and being new to picoCTF, this was just learning out the basics for picoCTF with it's basic tools and commands
